<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="style.css"> 
<link rel="icon" href="sunmoon.ico" type="image/x-icon">
<title>Music → Scrapbook</title>
<style>
:root{
  --bg:#0b0f15; --bar:#05080c; --line:#343b44; --muted:#9aa3ad; --accent:#6ee7ff; --panel:#0d1116;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
.top-bar{background:var(--bar);height:40px;display:flex;align-items:center;padding:0 14px;border-bottom:1px solid var(--line)}
.title{font-size:14px;margin:0}
.controls{margin-left:auto;display:flex;gap:8px;align-items:center}
.controls label,.controls button,.controls select{
  background:#0f1317;border:1px solid #1f252b;padding:6px 8px;border-radius:6px;
  font-size:13px;color:var(--muted);cursor:pointer
}
.controls button.primary{color:var(--accent);border-color:rgba(110,231,255,0.12)}
.main{display:grid;grid-template-columns:1fr 320px;gap:12px;height:calc(100vh - 40px);padding:12px}
.left{background:#071017;border-radius:8px;overflow:auto;padding:8px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start}
.thumb{border-radius:6px;overflow:hidden;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,0.4)}
.thumb img{height:auto;width:auto;max-width:300px;display:block;border-radius:6px}
.right{padding:12px;background:var(--panel);border-radius:8px;border:1px solid #0f1317;display:flex;flex-direction:column;gap:12px}
.section-title{font-size:13px;color:var(--muted);margin-bottom:6px}
.small{font-size:12px;color:var(--muted)}
.badge{padding:4px 8px;background:#081018;border-radius:6px;border:1px solid #122028;color:var(--muted);font-size:12px}
#playerControls input[type=range]{width:100%}
#spectrum,#waveform{width:100%;background:#05080c;border-radius:6px;display:block;margin-bottom:6px}
</style>
</head>
<body>
<div class="top-bar">
  <h1 class="title">Music → Scrapbook</h1>
  <div class="controls">
    <input id="file" type="file" accept=".mp3,.wav,.ogg,audio/*,video/*,video/mp4,video/webm,video/ogg" style="display:none" />
    <label for="file">Load audio</label>
    <button id="playBtn" class="primary" disabled>Play</button>
    <button id="pauseBtn" disabled>Pause</button>
    <select id="sceneType">
      <option value="Landscape">Landscape</option>
      <option value="Person">Person</option>
      <option value="City">City</option>
      <option value="Fantasy">Fantasy</option>
      <option value="Scene">Scene</option>
    </select>
    <button id="genBtn">Generate Scrapbook</button>
  </div>
</div>

<div class="main">
  <div class="left" id="gallery"></div>
  <div class="right">
    <div class="section-title">Loaded Audio</div>
    <div id="audioName" class="small">No file loaded</div>

    <div class="section-title">Audio Player</div>
    <div id="playerControls" class="small">
      <input type="range" id="seekBar" min="0" max="100" value="0">
      <div><span id="currentTime">0:00</span> / <span id="duration">0:00</span></div>
    </div>

    <div class="section-title">Feature Visualizer</div>
    <canvas id="spectrum" width="280" height="60"></canvas>
    <canvas id="waveform" width="280" height="60"></canvas>
    <div id="moodLabel" class="badge">Mood: Neutral</div>

    <div class="section-title">Live Prompt</div>
    <div id="livePrompt" class="small">No prompt yet</div>

    <div class="section-title">Prompt used</div>
    <div id="promptText" class="small">No prompt yet</div>
  </div>
</div>

<script>
const gallery = document.getElementById('gallery');
const seekBar = document.getElementById('seekBar');
const currentTimeEl = document.getElementById('currentTime');
const durationEl = document.getElementById('duration');
const livePromptEl = document.getElementById('livePrompt');
const moodLabel = document.getElementById('moodLabel');

let audioCtx, analyser, sourceNode, dataArray, timeArray, bufferLength, mediaElement;
const usedImageIds = new Set();
const PEXELS_KEY = 'c5JRSHU3S4Y9yYM9eg8lZ3twpVXbc4S7qWl92do2xbUUF1ex9BYy10dT';

// ---------------- AUDIO ----------------
function ensureAudioCtx(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.8;
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    timeArray = new Uint8Array(bufferLength);
  }
}
function connectSource(node){
  ensureAudioCtx();
  if(sourceNode) sourceNode.disconnect();
  sourceNode = node;
  sourceNode.connect(analyser);
  analyser.connect(audioCtx.destination);
  document.getElementById('playBtn').disabled=false;
  document.getElementById('pauseBtn').disabled=false;
}

// ---------------- FEATURES ----------------
function getFeatures() {
  if(!analyser) return {};
  analyser.getByteFrequencyData(dataArray);
  analyser.getByteTimeDomainData(timeArray);

  let sum=0, low=0, mid=0, high=0, peak=0, zc=0, prev=128;
  let fluxSum=0; 
  if(!getFeatures.prevSpectrum) getFeatures.prevSpectrum=new Float32Array(bufferLength);
  const prevSpectrum = getFeatures.prevSpectrum;

  for(let i=0;i<dataArray.length;i++){
    const val = dataArray[i]; sum += val*val;
    if(i<dataArray.length*0.1) low+=val;
    else if(i<dataArray.length*0.4) mid+=val;
    else high+=val;
    if(val>peak) peak=val;
    const tval = timeArray[i];
    if((tval-128)*(prev-128)<0) zc++;
    prev = tval;
    fluxSum += Math.abs(val - prevSpectrum[i]);
    prevSpectrum[i] = val;
  }

  const rms = Math.sqrt(sum/dataArray.length);
  const energy = Math.min(1, rms/128);
  const dynamicRange = Math.min(1, (peak-rms)/128);
  const centroid = dataArray.reduce((a,v,i)=>a+i*v,0)/(sum||1)/dataArray.length;
  const spread = dataArray.reduce((a,v,i)=>a+v*Math.pow(i-centroid,2),0)/(sum||1)/dataArray.length;
  const rhythm = peak/128;
  const bassRatio = low/(low+mid+high);
  const midRatio = mid/(low+mid+high);
  const trebleRatio = high/(low+mid+high);
  const zcr = zc/dataArray.length;
  const spectralFlux = fluxSum/dataArray.length;
  const tempoEst = rhythm*180;
  const tonality = bassRatio<0.5&&trebleRatio<0.5?0.7:0.3;
  const pitch = centroid;

  let totalEnergy = dataArray.reduce((a,v)=>a+v,0);
  let threshold = totalEnergy*0.85, cumulative=0, rolloff=0;
  for(let i=0;i<dataArray.length;i++){cumulative+=dataArray[i]; if(cumulative>=threshold){rolloff=i/dataArray.length; break;}}
  const geoMean = Math.exp(dataArray.reduce((a,v)=>a+Math.log(v+1),0)/dataArray.length);
  const arithMean = totalEnergy/dataArray.length;
  const flatness = geoMean/arithMean;
  const crest = peak/(rms||1);

  return {energy,dynamicRange,centroid,spread,rhythm,bassRatio,midRatio,trebleRatio,zcr,spectralFlux,tempoEst,tonality,pitch,rolloff,flatness,crest};
}

// ---------------- QUERY BUILDER ----------------
function pickRandom(arr){return arr[Math.floor(Math.random()*arr.length)];}

function buildQuery(features) {
  if (!features) return "";
  const scene = document.getElementById('sceneType').value;
  let adjectives = [];
  // Energy → mood
  if (features.energy > 0.8) adjectives.push(pickRandom(["explosive","vibrant","ecstatic","stormy","fiery"]));
  else if (features.energy > 0.5) adjectives.push(pickRandom(["uplifting","bouncy","bright","joyful","playful"]));
  else adjectives.push(pickRandom(["calm","mellow","soothing","dreamy","serene"]));
  // Dynamics
  adjectives.push(pickRandom(features.dynamicRange > 0.5 ? 
    ["dramatic","bold","thundering","eruptive"] : 
    ["fragile","gentle","whispery","subtle"]));
  // Timbre
  adjectives.push(pickRandom(features.flatness > 0.5 ? 
    ["noisy","gritty","rough","chaotic"] : 
    ["smooth","velvety","airy","shimmering"]));
  // Spectrum rolloff → warmth/brightness
  adjectives.push(features.rolloff > 0.7 ? pickRandom(["bright","metallic","glassy"]) : pickRandom(["warm","dark","dusty"]));
  // Crest factor → punchiness
  adjectives.push(features.crest > 4 ? pickRandom(["punchy","snappy","percussive"]) : pickRandom(["soft","flowing","blended"]));
  // Tempo
  adjectives.push(features.tempoEst > 140 ? "fast-paced" : features.tempoEst > 90 ? "steady" : "slow");
  const segment = Math.floor(mediaElement.currentTime / 5);
  return scene + " " + adjectives.join(" ") + " segment-" + segment;
}


// ---------------- SCRAPBOOK ----------------
function pushImages(photos, query) {
  photos.forEach(p => {
    if (usedImageIds.has(p.id)) return;
    usedImageIds.add(p.id);

    const div = document.createElement('div');
    div.className = 'thumb';
    const img = document.createElement('img');
    img.src = p.src.large2x;
    img.alt = query;
    img.title = query;
    div.appendChild(img);

    div.addEventListener('click', () => window.open(p.url, '_blank'));
    gallery.prepend(div);
  });
}

async function generateScrapbook(){
  const features = getFeatures();
  const query = buildQuery(features);
  document.getElementById('promptText').textContent = query;

  try{
    const res = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=6`,{
      headers:{Authorization:PEXELS_KEY}
    });
    if(!res.ok) throw new Error(`API error ${res.status}`);
    const data = await res.json();
    if(!data.photos || data.photos.length===0) return;
    pushImages(data.photos, query);
  } catch(err){ console.error(err); alert("Image fetch failed."); }
}

// ---------------- AUDIO FILE ----------------
document.getElementById('file').addEventListener('change', e=>{
  const file = e.target.files?.[0]; if(!file) return;
  document.getElementById('audioName').textContent = file.name;

  if(!mediaElement) mediaElement=new Audio();
  mediaElement.src = URL.createObjectURL(file);
  mediaElement.crossOrigin="anonymous";

  mediaElement.onloadedmetadata = ()=>{
    durationEl.textContent = formatTime(mediaElement.duration);
    ensureAudioCtx();
    const track = audioCtx.createMediaElementSource(mediaElement);
    connectSource(track);

    mediaElement.addEventListener('timeupdate', ()=>{
      const current = mediaElement.currentTime;
      const duration = mediaElement.duration || 0;
      currentTimeEl.textContent = formatTime(current);
      seekBar.value = duration>0 ? (current/duration)*100 : 0;

      const features = getFeatures();
      if(features) {
        livePromptEl.textContent = buildQuery(features);
        moodLabel.textContent = "Mood: " + (features.energy>0.7?"🔥 Energetic":features.tempoEst<80?"🌊 Chill":"⚡ Balanced");
      }
    });

    mediaElement.play();
  };
});

// ---------------- PLAYER ----------------
function formatTime(sec){ const m=Math.floor(sec/60); const s=Math.floor(sec%60); return `${m}:${s.toString().padStart(2,'0')}`; }
seekBar.addEventListener('input', ()=>{ if(!mediaElement) return; mediaElement.currentTime = (seekBar.value/100)*(mediaElement.duration||0); });
document.getElementById('playBtn').addEventListener('click', async ()=>{ if(!audioCtx) return; if(audioCtx.state==='suspended') await audioCtx.resume(); mediaElement?.play(); });
document.getElementById('pauseBtn').addEventListener('click', ()=>mediaElement?.pause());
document.getElementById('genBtn').addEventListener('click', generateScrapbook);

// ---------------- VISUALIZER ----------------
function drawSpectrum() {
  if(!analyser) {requestAnimationFrame(drawSpectrum); return;}
  const spectrumCanvas = document.getElementById('spectrum');
  const waveCanvas = document.getElementById('waveform');
  const spectrumCtx = spectrumCanvas.getContext('2d');
  const waveCtx = waveCanvas.getContext('2d');

  analyser.getByteFrequencyData(dataArray);
  analyser.getByteTimeDomainData(timeArray);

  // Spectrum
  spectrumCtx.clearRect(0,0,spectrumCanvas.width,spectrumCanvas.height);
  const barWidth = (spectrumCanvas.width / dataArray.length)*2;
  let x = 0;
  for (let i=0;i<dataArray.length;i+=4){
    const barHeight = dataArray[i]/2;
    spectrumCtx.fillStyle = "#6ee7ff";
    spectrumCtx.fillRect(x, spectrumCanvas.height-barHeight, barWidth, barHeight);
    x += barWidth+1;
  }

  // Waveform
  waveCtx.clearRect(0,0,waveCanvas.width,waveCanvas.height);
  waveCtx.beginPath();
  waveCtx.moveTo(0, waveCanvas.height/2);
  for (let i=0;i<timeArray.length;i++){
    const y = (timeArray[i]/255.0)*waveCanvas.height;
    const xpos = (i/timeArray.length)*waveCanvas.width;
    waveCtx.lineTo(xpos,y);
  }
  waveCtx.strokeStyle = "#6ee7ff";
  waveCtx.lineWidth = 2;
  waveCtx.stroke();

  requestAnimationFrame(drawSpectrum);
}
drawSpectrum();
</script>
</body>
</html>